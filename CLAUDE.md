# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

Hexalith (HexLogoGen) is a modern geometric logo generator written in Rust. It creates unique hexagonal designs with minimal configuration, inspired by the Mesos Framework Logo Generator style. The tool generates random, geometric logos based on triangles within a hexagonal grid.

## Project Structure

```
hexalith/
├── src/
│   ├── cli/              # Command-line interface handling
│   ├── generator/        # Core logic for logo generation
│   │   ├── grid/         # Hexagonal grid geometry
│   │   ├── shape/        # Shape generation algorithms  
│   │   └── color/        # Color management
│   ├── svg/              # SVG output generation
│   ├── png/              # PNG conversion from SVG
│   ├── utils/            # Helper functions
│   ├── lib.rs            # Library exports
│   └── main.rs           # Application entry point
├── tests/                # Integration tests
└── examples/             # Example usages
```

## Architecture

This project follows a modular architecture with the following components:

1. **CLI Module**: Handles user input, argument parsing using Clap, and help documentation
2. **Generator Module**: Core logic for creating logos
   - Hexagon/Grid Generator: Creates the base grid with triangular cells
   - Shape Generator: Creates random polygon shapes
   - Color Manager: Handles color selection and blending
3. **SVG Module**: Converts generated shapes to SVG format
4. **PNG Module**: Converts SVG to PNG when needed
5. **Utilities Module**: Helper functions, random number generation, etc.
6. **Library API**: Public API for integration with other Rust projects

## Development Environment

This project uses Nix Flakes for development environment management. Always run Rust commands through the Nix environment:

```bash
# Instead of direct cargo commands, use:
nix develop -c cargo build
nix develop -c cargo test
nix develop -c cargo run

# Or enter the development shell with:
nix develop
# Then you can run cargo commands directly
```

If you have direnv installed and enabled, the Nix environment will be automatically activated when you enter the directory, and you can use cargo commands directly.

## Development Commands

```bash
# Build the project
nix develop -c cargo build
# Or use the devshell command:
rs-build

# Run the project
nix develop -c cargo run
# Or use the devshell command:
rs-run

# Run with specific options
nix develop -c cargo run -- --seed 12345 --format png logo.png
# Or use the devshell command:
rs-run --seed 12345 --format png logo.png

# Run tests
nix develop -c cargo test
# Or use the devshell command:
rs-test

# Run specific test
nix develop -c cargo test <test_name>
# Or use the devshell command:
rs-test <test_name>

# Build for release
nix develop -c cargo build --release
# Or use the devshell command:
rs-release

# Check for compilation errors without building
nix develop -c cargo check
# Or use the devshell command:
rs-check

# Format code
nix develop -c cargo fmt
# Or use the devshell command:
rs-fmt

# Run linter
nix develop -c cargo clippy
# Or use the devshell command (uses direct binary path to clippy):
rs-clippy
```

## CLI Interface

The command-line interface includes these options:

```
Usage: hexlogogen [OPTIONS] [OUTPUT]

Arguments:
  [OUTPUT]  Output file path [default: logo.svg]

Options:
  -s, --seed <SEED>            Seed for deterministic generation
  -u, --uuid <UUID>            UUID for deterministic generation (overrides seed)
  -c, --colors <COLORS>        Color scheme [default: default]
  -n, --shapes <SHAPES>        Number of shapes to generate [default: 3]
  -g, --grid-size <GRID_SIZE>  Grid density (2-8) [default: 2]
  -o, --opacity <OPACITY>      Shape opacity [default: 0.8]
  --overlap                  Allow shapes to overlap with blended colors
  -w, --width <WIDTH>          Output width in pixels (PNG only) [default: 512]
  -H, --height <HEIGHT>        Output height in pixels (PNG only) [default: 512]
  -f, --format <FORMAT>        Output format [default: svg] [possible values: svg, png]
  -v, --verbose                Enable verbose output
  -h, --help                   Print help
  -V, --version                Print version
```

## Dependencies

The project relies on these Rust crates:

- **Clap**: Command-line argument parsing
- **uuid**: UUID generation and handling
- **rand** and **rand_chacha**: Random number generation
- **svg**: SVG string generation
- **tiny-skia** and **resvg/usvg**: For PNG output

## Technical Implementation Notes

- The hexagonal grid is divided into triangular cells
- For grid density `n`, the hexagon is divided into `6n²` triangular cells
- Grid density values range from 2 to 8 (default: 2)
- Logos are generated by creating multiple shapes made of connected triangular cells
- With grid density=2, the generator creates a grid with exactly 24 triangles like the original
- Shapes can optionally overlap with color blending at intersections
- Shapes can have different colors with configurable opacity
- The tool supports both random and deterministic (seeded) generation

## Code Standards

- Follow idiomatic Rust practices
- Use meaningful variable and function names
- Write unit tests for core functionality
- Implement proper error handling with the Result type
- Add documentation comments for public APIs
- Keep the code clean, modular and maintainable

## Common Tasks

### Adding a New Feature

1. Identify the module where the feature belongs
2. Implement the core functionality in the appropriate module
3. Update the CLI interface in `src/cli/mod.rs` if needed
4. Add tests for the new functionality
5. Update documentation in README.md and CLAUDE.md

### Fixing a Bug

1. Write a test that reproduces the bug
2. Fix the bug in the appropriate module
3. Ensure all tests pass
4. Document the fix in the commit message

### Adding a New Output Format

1. Create a new module in `src/` for the format
2. Implement conversion from the internal representation
3. Add the new format to the Format enum in `src/cli/mod.rs`
4. Update the CLI to handle the new format
5. Add tests for the new format